name: Build wheels

on:
  workflow_dispatch:

permissions:
  contents: read
  actions: write

jobs:
  build:
    name: build on ${{ matrix.os }} (${{ matrix.target }} - ${{ matrix.interpreter || 'all' }})
    strategy:
      fail-fast: false
      matrix:
        include:
          # Linux builds - modern architectures only
          - os: linux
            target: amd64
            interpreter: 3.10 3.11 3.12 3.13
          - os: linux
            target: aarch64
            interpreter: 3.10 3.11 3.12 3.13

          # macOS builds
          - os: macos
            target: x86_64
            interpreter: 3.10 3.11 3.12 3.13
          - os: macos
            target: aarch64
            interpreter: 3.10 3.11 3.12 3.13

          # Windows builds
          - os: windows
            target: x86_64
            interpreter: 3.10 3.11 3.12 3.13 
          - os: windows
            target: aarch64
            runs-on: windows-11-arm
            interpreter: 3.11 3.12 3.13

    runs-on: ${{ matrix.runs-on || format('{0}-latest', (matrix.os == 'linux' && 'ubuntu') || matrix.os) }}
    steps:
      - uses: actions/checkout@v4

      - name: Remove committed artifacts (POSIX)
        if: runner.os != 'Windows'
        run: |
          rm -rf wheelhouse dist release-archives || true

      - name: Remove committed artifacts (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $paths = @("wheelhouse","dist","release-archives")
          foreach ($p in $paths) {
            if (Test-Path $p) {
              Remove-Item -Recurse -Force $p
            }
          }

      - name: set up python
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"
          architecture: ${{ matrix.python-architecture || 'x64' }}

      - name: Install OpenSSL development headers (Ubuntu)
        if: matrix.os == 'linux'
        run: |
          if command -v apt-get > /dev/null; then
            sudo apt-get update
            sudo apt-get install -y libssl-dev
          elif command -v yum > /dev/null; then
            yum install -y openssl-devel openssl-static
          fi

      - name: Install dependencies (macOS)
        if: matrix.os == 'macos'
        run: |
          brew install openssl@3 sqlcipher pkg-config
          echo "OPENSSL_DIR=$(brew --prefix openssl@3)" >> $GITHUB_ENV
          echo "PKG_CONFIG_PATH=$(brew --prefix openssl@3)/lib/pkgconfig:$(brew --prefix sqlcipher)/lib/pkgconfig" >> $GITHUB_ENV
          # Force dynamic linking so delocate can bundle the dylibs
          echo "OPENSSL_STATIC=0" >> $GITHUB_ENV
          echo "SQLCIPHER_STATIC=0" >> $GITHUB_ENV
          # Tell Rust linker where to find the dylibs at build time
          echo "RUSTFLAGS=-L $(brew --prefix sqlcipher)/lib -L $(brew --prefix openssl@3)/lib" >> $GITHUB_ENV
          # Set rpath so the binary can find dylibs before delocate processes them
          echo "DYLD_LIBRARY_PATH=$(brew --prefix openssl@3)/lib:$(brew --prefix sqlcipher)/lib" >> $GITHUB_ENV

      - name: Install dependencies (Windows)
        if: matrix.os == 'windows'
        shell: pwsh
        run: |
          # Determine architecture
          $arch = if ("${{ matrix.target }}" -eq "aarch64") { "arm64" } else { "x64" }
          # Use dynamic libraries so delvewheel can bundle them
          $vcpkgTriplet = "${arch}-windows"
          
          # Check if vcpkg exists and clean it if needed
          if (Test-Path "C:\vcpkg") {
            Remove-Item -Path "C:\vcpkg" -Recurse -Force
          }
          
          # Install vcpkg and build dependencies
          git clone https://github.com/Microsoft/vcpkg.git C:\vcpkg
          cd C:\vcpkg
          .\bootstrap-vcpkg.bat
          .\vcpkg integrate install
          
          # Install OpenSSL and SQLite3 for the correct architecture
          Write-Host "Installing packages for $vcpkgTriplet"
          .\vcpkg install "openssl:$vcpkgTriplet" "sqlite3:$vcpkgTriplet"
          
          # Set environment variables for the correct architecture
          $installPath = "C:\vcpkg\installed\$vcpkgTriplet"
          
          echo "OPENSSL_DIR=$installPath" >> $env:GITHUB_ENV
          echo "OPENSSL_LIB_DIR=$installPath\lib" >> $env:GITHUB_ENV
          echo "OPENSSL_INCLUDE_DIR=$installPath\include" >> $env:GITHUB_ENV
          echo "SQLCIPHER_LIB_DIR=$installPath\lib" >> $env:GITHUB_ENV
          echo "SQLCIPHER_INCLUDE_DIR=$installPath\include" >> $env:GITHUB_ENV
          echo "SQLITE3_LIB_DIR=$installPath\lib" >> $env:GITHUB_ENV
          # For dynamic linking, remove the explicit .lib references and static flag
          echo "RUSTFLAGS=-L $installPath\lib" >> $env:GITHUB_ENV
          # Don't set OPENSSL_STATIC
          
          # For ARM64, we need to use the bundled SQLite since cross-compilation is complex
          if ("${{ matrix.target }}" -eq "aarch64") {
            echo "LIBSQLITE3_SYS_USE_BUNDLED=1" >> $env:GITHUB_ENV
            Write-Host "Using bundled SQLite for ARM64"
          } else {
            echo "LIBSQLITE3_SYS_USE_PKG_CONFIG=1" >> $env:GITHUB_ENV
          }
          
          # Verify the libraries exist
          if (Test-Path "$installPath\lib") {
            Write-Host "Library directory found. Contents:"
            Get-ChildItem "$installPath\lib" | Select-Object Name
          } else {
            Write-Host "Library directory not found!"
          }

          # If sqlcipher.lib is missing but sqlite3.lib exists, create a copy as a fallback
          if (-not (Test-Path "$installPath\lib\sqlcipher.lib")) {
            if (Test-Path "$installPath\lib\sqlite3.lib") {
              Write-Host "sqlcipher.lib missing — creating from sqlite3.lib as fallback"
              Copy-Item "$installPath\lib\sqlite3.lib" "$installPath\lib\sqlcipher.lib" -Force
              Write-Host "Created $installPath\lib\sqlcipher.lib"
            } else {
              Write-Host "Neither sqlcipher.lib nor sqlite3.lib found in $installPath\lib"
            }
          } else {
            Write-Host "sqlcipher.lib already present"
          }

          # Export LIB so MSVC link.exe can find vcpkg libs
          echo "LIB=$installPath\lib" >> $env:GITHUB_ENV
          
      - run: pip install -U ruff typing_extensions setuptools delocate delvewheel

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable
          targets: ${{ matrix.os == 'linux' && (matrix.target == 'aarch64' && 'aarch64-unknown-linux-gnu' || 'x86_64-unknown-linux-gnu') || matrix.os == 'macos' && (matrix.target == 'x86_64' && 'x86_64-apple-darwin' || 'aarch64-apple-darwin') || matrix.os == 'windows' && (matrix.target == 'aarch64' && 'aarch64-pc-windows-msvc' || 'x86_64-pc-windows-msvc') }}

      - name: Install maturin
        run: pip install maturin

      # =================== LINUX ===================
      - name: Build Linux wheels
        if: matrix.os == 'linux'
        run: |
          # Install build dependencies
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            pkg-config \
            libssl-dev \
            curl \
            gcc \
            g++ \
            make \
            cmake \
            autoconf \
            automake \
            libtool
          
          # For x86_64/amd64, just use system libraries
          if [ "${{ matrix.target }}" = "x86_64" ] || [ "${{ matrix.target }}" = "amd64" ]; then
            # Install SQLCipher from source with system OpenSSL
            cd /tmp
            curl -fsSL https://github.com/sqlcipher/sqlcipher/archive/refs/tags/v4.6.1.tar.gz | tar xz
            cd sqlcipher-4.6.1
            
            CFLAGS="-DSQLITE_HAS_CODEC -fPIC" \
            CPPFLAGS="-fPIC" \
            LDFLAGS="-fPIC" \
            ./configure \
              --prefix=/usr/local \
              --enable-tempstore=yes \
              --enable-static=yes \
              --disable-shared \
              --with-crypto-lib=openssl \
              --with-pic
            
            make -j$(nproc)
            sudo make install
            
            cd ${{ github.workspace }}
            
            # Build wheels for x86_64/amd64
            sdist_flag="--sdist"
            for py in ${{ matrix.interpreter }}; do
              echo "Building for Python ${py}"
              OPENSSL_STATIC=1 maturin build --release --interpreter ${py} ${sdist_flag}
              sdist_flag=""
            done
          else
            # Cross-compilation for aarch64
            sudo apt-get install -y gcc-aarch64-linux-gnu g++-aarch64-linux-gnu libc6-dev-arm64-cross
            export CC=aarch64-linux-gnu-gcc
            export CXX=aarch64-linux-gnu-g++
            export AR=aarch64-linux-gnu-ar
            export CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc
            RUST_TARGET="aarch64-unknown-linux-gnu"
            OPENSSL_TARGET="linux-aarch64"
            HOST_FLAG="--host=aarch64-linux-gnu"
            
            # Build OpenSSL for cross target
            PREFIX=/tmp/deps-${{ matrix.target }}
            mkdir -p "${PREFIX}"
            
            echo "Building OpenSSL 3.3.2 for ${{ matrix.target }}"
            cd /tmp
            curl -fsSL https://www.openssl.org/source/openssl-3.3.2.tar.gz | tar xz
            cd openssl-3.3.2
            
            ./Configure ${OPENSSL_TARGET} \
              --prefix="${PREFIX}" \
              --openssldir="${PREFIX}/ssl" \
              no-shared \
              no-async \
              -fPIC
            
            make -j$(nproc)
            make install_sw
            
            # Build SQLCipher for cross target
            echo "Building SQLCipher 4.6.1 for ${{ matrix.target }}"
            cd /tmp
            curl -fsSL https://github.com/sqlcipher/sqlcipher/archive/refs/tags/v4.6.1.tar.gz | tar xz
            cd sqlcipher-4.6.1
            
            CPPFLAGS="-I${PREFIX}/include" \
            LDFLAGS="-L${PREFIX}/lib" \
            LIBS="-lcrypto -lpthread" \
            ./configure \
              --prefix="${PREFIX}" \
              --enable-tempstore=yes \
              --enable-static=yes \
              --disable-shared \
              --with-crypto-lib=openssl \
              ${HOST_FLAG}
            
            make -j$(nproc)
            make install
            
            cd ${{ github.workspace }}
            
            # Export all the environment variables for cross-compilation
            export OPENSSL_DIR="${PREFIX}"
            export OPENSSL_STATIC=1
            export OPENSSL_LIB_DIR="${PREFIX}/lib"
            export OPENSSL_INCLUDE_DIR="${PREFIX}/include"
            export SQLCIPHER_LIB_DIR="${PREFIX}/lib"
            export SQLCIPHER_INCLUDE_DIR="${PREFIX}/include"
            export PKG_CONFIG_PATH="${PREFIX}/lib/pkgconfig"
            export PKG_CONFIG_ALLOW_CROSS=1
            
            # Build wheels for aarch64
            sdist_flag="--sdist"
            for py in ${{ matrix.interpreter }}; do
              echo "Building for Python ${py} on ${RUST_TARGET}"
              
              AARCH64_UNKNOWN_LINUX_GNU_OPENSSL_DIR="${PREFIX}" \
              AARCH64_UNKNOWN_LINUX_GNU_OPENSSL_STATIC=1 \
              AARCH64_UNKNOWN_LINUX_GNU_OPENSSL_LIB_DIR="${PREFIX}/lib" \
              AARCH64_UNKNOWN_LINUX_GNU_OPENSSL_INCLUDE_DIR="${PREFIX}/include" \
              maturin build --release --target ${RUST_TARGET} --interpreter ${py} ${sdist_flag}
              sdist_flag=""
            done
          fi
          
          # Move all wheels to dist directory
          mkdir -p dist
          find target -name "*.whl" -exec mv {} dist/ \;
          find target -name "*.tar.gz" -exec mv {} dist/ \;

      # =================== MACOS ===================
      - name: Build macOS wheels
        if: matrix.os == 'macos'
        run: |
          # Dependencies already installed in earlier step
          # Build wheels for each Python version
          case "${{ matrix.target }}" in
            x86_64)
              RUST_TARGET="x86_64-apple-darwin"
              ;;
            aarch64)
              RUST_TARGET="aarch64-apple-darwin"
              ;;
          esac
          
          # Force dynamic linking by hiding static libraries
          echo "Forcing dynamic linking by hiding static libraries..."
          OPENSSL_PREFIX=$(brew --prefix openssl@3)
          SQLCIPHER_PREFIX=$(brew --prefix sqlcipher)
          
          echo "OpenSSL prefix: $OPENSSL_PREFIX"
          echo "SQLCipher prefix: $SQLCIPHER_PREFIX"
          
          # Temporarily move ALL static libraries to force dynamic linking
          find "$OPENSSL_PREFIX/lib" -name "*.a" | while read -r static_lib; do
            sudo mv "$static_lib" "${static_lib}.bak"
            echo "Moved $static_lib to ${static_lib}.bak"
          done
          find "$SQLCIPHER_PREFIX/lib" -name "*.a" 2>/dev/null | while read -r static_lib; do
            sudo mv "$static_lib" "${static_lib}.bak"
            echo "Moved $static_lib to ${static_lib}.bak"
          done
          
          # Also check for and move static libs in system paths that might be found first
          if [ -d "/usr/local/lib" ]; then
            find /usr/local/lib -name "libssl.a" -o -name "libcrypto.a" -o -name "libsqlcipher.a" 2>/dev/null | while read -r static_lib; do
              sudo mv "$static_lib" "${static_lib}.bak" 2>/dev/null || true
              echo "Moved system $static_lib to ${static_lib}.bak"
            done
          fi
          
          # Export dynamic linking flags for each build
          export OPENSSL_STATIC=0
          export SQLCIPHER_STATIC=0
          export OPENSSL_DIR=$OPENSSL_PREFIX
          export OPENSSL_LIB_DIR="$OPENSSL_PREFIX/lib"
          export OPENSSL_INCLUDE_DIR="$OPENSSL_PREFIX/include"
          export PKG_CONFIG_PATH="$OPENSSL_PREFIX/lib/pkgconfig:$SQLCIPHER_PREFIX/lib/pkgconfig"
          # Force the linker to use dylibs with explicit paths
          export RUSTFLAGS="-L $SQLCIPHER_PREFIX/lib -L $OPENSSL_PREFIX/lib -C link-arg=-Wl,-rpath,$OPENSSL_PREFIX/lib"
          # Tell the linker to prefer dynamic libraries
          export OPENSSL_NO_VENDOR=1
          # Force dynamic for libsqlite3-sys as well
          export LIBSQLITE3_SYS_USE_PKG_CONFIG=1
          
          # Debug: Check what we're linking against
          echo "OPENSSL_DIR=$OPENSSL_DIR"
          echo "PKG_CONFIG_PATH=$PKG_CONFIG_PATH"
          echo "RUSTFLAGS=$RUSTFLAGS"
          echo "OPENSSL_STATIC=$OPENSSL_STATIC"
          echo "Available dylibs:"
          ls -la $OPENSSL_PREFIX/lib/*.dylib || true
          ls -la $SQLCIPHER_PREFIX/lib/*.dylib || true
          
          sdist_flag="--sdist"
          for py in ${{ matrix.interpreter }}; do
            echo "Building for Python ${py} on ${RUST_TARGET}"
            maturin build --release --target ${RUST_TARGET} --interpreter ${py} ${sdist_flag}
            sdist_flag=""
          done
          
          # DO NOT RESTORE STATIC LIBRARIES YET - we need them hidden for delocate to work
          
          # Verify dynamic linking before delocating
          echo "Checking for dynamic dependencies in built wheels..."
          for wheel in target/wheels/*.whl; do
            echo "Checking $wheel"
            tmpdir=$(mktemp -d)
            unzip -q "$wheel" -d "$tmpdir"
            echo "Contents of wheel:"
            find "$tmpdir" -name "*.so" -o -name "*.dylib" | head -5
            echo "Dynamic dependencies:"
            find "$tmpdir" -name "*.so" -exec otool -L {} \; | grep -E "(libssl|libcrypto|sqlcipher)" || echo "WARNING: No external dylib deps found!"
            rm -rf "$tmpdir"
          done
          
          # Bundle dependent dylibs so end users do not need Homebrew-installed libraries.
          echo "Looking for wheels to delocate..."
          find target/wheels -name "*.whl" -ls || true
          
          BUNDLE_DIR="target/delocated-wheelhouse"
          mkdir -p "${BUNDLE_DIR}"
          find target/wheels -name "*.whl" -print0 | while IFS= read -r -d '' wheel; do
            echo "Delocating: $wheel"
            delocate-wheel -v -w "${BUNDLE_DIR}" "$wheel"
            rm "$wheel"
          done
          
          # Move delocated wheels back to target/wheels for consistency
          find "${BUNDLE_DIR}" -name "*.whl" -exec mv {} target/wheels/ \;
          
          # NOW restore static libraries after delocate is done
          find "$OPENSSL_PREFIX/lib" -name "*.a.bak" | while read -r backup; do
            original="${backup%.bak}"
            sudo mv "$backup" "$original"
            echo "Restored $original"
          done
          find "$SQLCIPHER_PREFIX/lib" -name "*.a.bak" 2>/dev/null | while read -r backup; do
            original="${backup%.bak}"
            sudo mv "$backup" "$original"
            echo "Restored $original"
          done
          if [ -d "/usr/local/lib" ]; then
            find /usr/local/lib -name "*.a.bak" 2>/dev/null | while read -r backup; do
              original="${backup%.bak}"
              sudo mv "$backup" "$original" 2>/dev/null || true
              echo "Restored system $original"
            done
          fi
          
          # Move all wheels to dist directory
          mkdir -p dist
          find target -name "*.whl" -exec mv {} dist/ \;
          find target -name "*.tar.gz" -exec mv {} dist/ \;

      # =================== WINDOWS ===================  
      - name: Build Windows wheels
        if: matrix.os == 'windows'
        shell: pwsh
        run: |
          # Determine architecture paths
          $arch = if ("${{ matrix.target }}" -eq "aarch64") { "arm64" } else { "x64" }
          # Use dynamic libraries
          $vcpkgTriplet = "${arch}-windows"
          $installPath = "C:\vcpkg\installed\$vcpkgTriplet"
          
          # Set environment variables for the build (ensure linker finds OpenSSL and sqlcipher)
          $env:OPENSSL_DIR = $installPath
          $env:OPENSSL_LIB_DIR = "$installPath\lib"
          $env:OPENSSL_INCLUDE_DIR = "$installPath\include"
          $env:SQLCIPHER_LIB_DIR = "$installPath\lib"
          $env:SQLCIPHER_INCLUDE_DIR = "$installPath\include"
          $env:SQLITE3_LIB_DIR = "$installPath\lib"
          # For dynamic linking
          $env:RUSTFLAGS = "-L $installPath\lib"
          # also set LIB so link.exe will search the directory
          $env:LIB = "$installPath\lib;$env:LIB"
          # Don't set OPENSSL_STATIC
          
          # Confirm sqlcipher.lib exists (helpful debug)
          if (Test-Path "$installPath\lib\sqlcipher.lib") {
            Write-Host "sqlcipher.lib found at $installPath\lib"
          } else {
            Write-Host "WARNING: sqlcipher.lib not found at $installPath\lib — link may fail"
          }
          
          # Build wheels for each Python version
          switch ("${{ matrix.target }}") {
            "x86_64" {
              $rustTarget = "x86_64-pc-windows-msvc"
            }
            "aarch64" {
              $rustTarget = "aarch64-pc-windows-msvc"
            }
          }
          
          $pythonVersions = "${{ matrix.interpreter }}".Split()
          $emitSdist = $true
          foreach ($py in $pythonVersions) {
            Write-Host "Building for Python $py on $rustTarget"
            $args = @("--release", "--target", $rustTarget, "--interpreter", $py)
            if ($emitSdist) {
              $args += "--sdist"
              $emitSdist = $false
            }
            maturin build @args
          }
          
          # Bundle dependent DLLs so end users do not need vcpkg-installed libraries.
          $bundleDir = Join-Path $PWD "target\delvewheel-wheelhouse"
          New-Item -ItemType Directory -Force -Path $bundleDir | Out-Null
          Get-ChildItem -Path target -Recurse -Filter *.whl | ForEach-Object {
            python -m delvewheel repair --add-path "$installPath\bin" -w $bundleDir $_.FullName
            Remove-Item $_.FullName
          }
          
          # Move all wheels to dist directory
          New-Item -ItemType Directory -Force -Path dist
          Get-ChildItem -Path target -Recurse -Include *.whl,*.tar.gz | Move-Item -Destination dist

      - run: ${{ (matrix.os == 'windows' && 'dir') || 'ls -lh' }} dist/

      - uses: actions/upload-artifact@v4
        with:
          name: pypi_files_${{ matrix.os }}_${{ matrix.target }}_${{ matrix.interpreter || 'all' }}
          path: dist

  # =================== COLLECT AND PACKAGE ===================
  collect-and-package:
    name: Collect wheels and create wheelhouse
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: write
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Remove committed artifacts (POSIX)
        if: runner.os != 'Windows'
        run: |
          rm -rf wheelhouse dist release-archives || true

      - name: Remove committed artifacts (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $paths = @("wheelhouse","dist","release-archives")
          foreach ($p in $paths) {
            if (Test-Path $p) {
              Remove-Item -Recurse -Force $p
            }
          }

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"
      
      - name: Install build tools
        run: |
          pip install build maturin setuptools wheel
      
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: all-artifacts
          pattern: pypi_files_*
      
      - name: Create wheelhouse and process files
        run: |
          # Create wheelhouse directory
          mkdir -p wheelhouse
          
          # Collect all artifacts
          find all-artifacts -name "*.whl" -exec cp {} wheelhouse/ \;
          find all-artifacts -name "*.tar.gz" -exec cp {} wheelhouse/ \;
          if ! ls wheelhouse/*.tar.gz >/dev/null 2>&1; then
            echo "ERROR: No sdists produced by maturin build." >&2
            exit 1
          fi
          
          # Generate SHA256 hashes for all files
          cd wheelhouse
          echo "Generating hash signatures..."
          
          # Create per-file .sha256 and master CHECKSUMS.sha256
          for file in *.whl *.tar.gz; do
            if [ -f "$file" ]; then
              sha256sum "$file" > "$file.sha256"
              echo "Generated hash for $file"
            fi
          done
          
          # Create master checksums file
          {
            echo "# SHA256 Checksums"
            echo "Generated on: $(date -u)"
            echo ""
            sha256sum *.whl *.tar.gz 2>/dev/null || true
          } > CHECKSUMS.sha256
          
          # Display summary
          echo "=================== Wheelhouse Contents ==================="
          ls -lh
          echo ""
          echo "=================== Checksums ==================="
          cat CHECKSUMS.sha256
      
      - name: Prepare release archives bundle
        run: |
          set -euo pipefail
          mkdir -p release-archives
          find wheelhouse -maxdepth 1 -type f \( -name "*.tar.gz" -o -name "*.tar.gz.sha256" -o -name "CHECKSUMS.sha256" \) -exec cp {} release-archives/ \;
          echo "Release archives:"
          ls -lh release-archives || true

      - name: Upload release archives
        uses: actions/upload-artifact@v4
        with:
          name: release-archives
          path: release-archives/
          retention-days: 30
      
      - name: Upload wheelhouse
        uses: actions/upload-artifact@v4
        with:
          name: wheelhouse
          path: wheelhouse/
          retention-days: 30
